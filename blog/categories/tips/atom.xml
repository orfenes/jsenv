<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tips | JS env - Ambiente dedicado a assuntos sobre Javascript]]></title>
  <link href="http://jsenv.com/blog/categories/tips/atom.xml" rel="self"/>
  <link href="http://jsenv.com/"/>
  <updated>2015-03-15T03:48:51+00:00</updated>
  <id>http://jsenv.com/</id>
  <author>
    <name><![CDATA[JS env team]]></name>
    <email><![CDATA[team.jsenv@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Membros Privados Em Javascript]]></title>
    <link href="http://jsenv.com/blog/2015/02/26/membros-privados-em-javascript/"/>
    <updated>2015-02-26T18:04:53+00:00</updated>
    <id>http://jsenv.com/blog/2015/02/26/membros-privados-em-javascript</id>
    <content type="html"><![CDATA[<p>Quem nunca se perguntou: <em>&ldquo;Como faço para deixar minhas variáveis e métodos privados com Javascript?&rdquo;</em>. Pois bem, tentarei de uma forma bem pragmática mostrar como fazemos isso.</p>

<p>Algumas pessoas acreditam que o Javascript não tem a capacidade de <em>&ldquo;esconder informações&rdquo;</em>, porque <code>object</code> não pode ter variáveis e métodos privados. Mas isso não passa de um mal-entendido.</p>

<h4><em>Sim! Objetos Javascript podem ter membros privados.</em></h4>

<p>Mas, antes de nos aprofundarmos vamos entender um pouco mais do funcionamento do Javascript em relação aos objetos:</p>

<!--more-->


<h2>Objects</h2>

<p>Javascript é fundamentalmente baseado em <em>objects</em>. Funções são objetos, arrays são objetos e Objetos são objetos. Mas o que são objetos?</p>

<p>Objetos são coleções de pares nome-valor. Os nomes são <em>strings</em> e o valores podem ser <em>strings</em>, <em>numbers</em>, <em>booleans</em> e <em>objects</em> (incluindo <em>arrays</em> e <em>funções</em>).</p>

<h2>Membros Públicos</h2>

<p>Os membros de um <code>object</code> são, sem exceção, públicos. Qualquer função pode acessar, modificar, deletar ou até mesmo adicionar novos membros. Existem duas maneiras principais de inserir membros em um novo objeto:</p>

<h3>No construtor</h3>

<p>Esta técnica é usualmente utilizada para iniciar instâncias de <em>variáveis</em> públicas. A variável <code>this</code> do construtor é usada para adicionar um membro ao objeto.</p>

<pre><code class="javascript">function Adicionar ( param ) {
    this.membro = param;
}
</code></pre>

<p>Então, se construírmos um novo objeto</p>

<pre><code class="javascript">var novo_objeto = new Adicionar( 'a-b-c' );
</code></pre>

<p>O valor de <code>novo_objeto.membro</code> será <code>a-b-c</code>.</p>

<h3>No prototype</h3>

<p>Esta técnica é utilizada para adicionar <em>métodos</em> públicos. Quando um membro é procurado dentro do próprio objeto e não é encontrado, ele é retirado do protótipo do Construtor do objeto. O mecânismo do <em>prototype</em> é usado para herança. O que também conserva a memória. Para adicionar um método para todos os objetos criados a partir do Construtor, adicione uma função ao protótipo do Construtor:</p>

<pre><code class="javascript">Adicionar.prototype.stamp = function ( string ) {
    return this.membro + string;
}
</code></pre>

<p>Então, podemos chamar o método:</p>

<pre><code class="javascript">novo_objeto.stamp( '-d-e-f' );
</code></pre>

<p>E o resultado será: <code>a-b-c-d-e-f</code>.</p>

<h2>Membros Privados</h2>

<p>Membros privados são criados pelo construtor. Variáveis comuns e parâmetros do <em>Construtor</em> se tornam membros privados.</p>

<pre><code class="javascript">function Container ( param ) {
    this.membro = param;
    var limite  = 3,
        that    = this;
}
</code></pre>

<p>Este construtor criou três variáveis privadas: <code>param</code>, <code>limite</code> e <code>that</code>. Elas estão anexadas ao objeto, mas não estão acessíveis fora, nem são acessíveis aos métodos públicos do objeto. Elas estão acessíveis aos métodos privados. Métodos privados são funções internas do <em>Construtor</em>.</p>

<pre><code class="javascript">function Container ( param ) {
    this.membro = param;
    var limite  = 3,
        that    = this;
    //
    function resgata () {
        if ( limite &gt; 0 &amp;&amp; 'undefined' !== typeof that.membro) {
            return true
        } else {
            return false
        }
    }
}
</code></pre>

<p>Por convenção, nós declaramos a variável <code>that</code> privada. Isso é usado para tornar o objeto disponível para os métodos privados, pois ao usar o <code>this</code> dentro da função ele apontará para o <code>this</code> dela mesma e não para o <code>this</code> do <em>Construtor</em>.</p>

<p>Métodos privados não podem ser invocados por métodos públicos. Para fazer os métodos privados utilizáveis, nós precisamos fazer com que ele tenha privilégios.</p>

<h2>Membros Privilegiados</h2>

<p>Um método privilegiado tem permissão para acessar variáveis e métodos privados, e é acessível por métodos públicos e externos. É possível deletar ou sobrescrever um método privilegiado, mas não é possível alterá-lo e nem forçá-lo a exibir seu conteúdo.</p>

<p>Métodos privilegiados são atribuídos com <code>this</code> dentro do <em>Construtor</em>.</p>

<pre><code class="javascript">function Container ( param ) {
    this.membro = param;
    var limite  = 3,
        that    = this;
    //
    function resgata () {
        if ( limite &gt; 0 ) {
            return true
        } else {
            return false
        }
    }
    //
    this.escreve = function () {
        return resgata() ? this.membro : null;
    }
}
</code></pre>

<p>Então temos o método privilegiado <code>escreve</code> que acessa os valores definidos dentro do <em>Construtor</em>, porém não pode alterá-los. \o/</p>

<p>Isso só é possível porque existem as <em>Closures</em> no Javascript.</p>

<h2>Closures</h2>

<p>Os padrões de membros <code>public</code>, <code>private</code> e <code>privileged</code> só se tornam possíveis pelo fato da linguagem Javascript possuir <em>Closures</em>.</p>

<p>Isso quer dizer que uma função interna sempre tem acesso as variáveis e parâmetros da função externa, mesmo depois de ela já ter executado.
Essa é uma propriedade muito poderosa da linguagem Javascript!</p>

<p>Métodos privados e privilegiados só podem ser atribuídos enquanto o objeto está sendo construído, já os públicos podem ser adicionados a qualquer momento.</p>

<h2>Padrões utilizando Closures</h2>

<h3>Membros Públicos</h3>

<pre><code class="javascript">function Construtor ( ... ) {
    this.membro = valor;
}
Construtor.prototype.membro = valor;
</code></pre>

<h3>Membros Privados</h3>

<pre><code class="javascript">function Construtor ( ... ) {
    var that = this,
        nome = valor;
    //
    function nome ( ... ) { ... };
}
</code></pre>

<p>Observação: a instrução da função</p>

<pre><code class="javascript">    function nome ( ... ) { ... };
</code></pre>

<p>é uma abreviação para:</p>

<pre><code class="javascript">    var nome = function nome ( ... ) { ... };
</code></pre>

<h3>Membros Privilegiados</h3>

<pre><code class="javascript">function Construtor ( ... ) {
    this.nome = function ( ... ) { ... }
}
</code></pre>

<p>Referência:</p>

<ul>
<li><strong> Douglas Crockford </strong>: <a href="http://javascript.crockford.com/private.html">http://javascript.crockford.com/private.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
